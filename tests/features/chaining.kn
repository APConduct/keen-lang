// =============================================================================
// CHAINING SYNTAX - Keen Language Examples
// =============================================================================
// This file demonstrates Keen's chaining capabilities:
// - Method chaining with .method().method()
// - Pipeline operator with |>
// - Field access chaining
// - Mixed chaining approaches
// =============================================================================

// =============================================================================
// METHOD CHAINING - Object-Oriented Style
// =============================================================================

// Basic method chaining
process_user_data(user: User): Result = {
    user
        .validate()
        .normalize()
        .save()
        .then(send_welcome_email)
}

// List processing with method chains
filter_and_transform_users(users: List): List = {
    users
        .filter(is_active)
        .map(normalize_user)
        .sort_by(get_email)
        .take(100)
}

// String processing chains
format_user_display(user: User): String = {
    user.name
        .trim()
        .to_lowercase()
        .replace(" ", "_")
        .concat("@company.com")
}

// Builder pattern with chaining
create_http_request(): HttpRequest = {
    HttpRequest.new()
        .method("POST")
        .url("/api/users")
        .header("Content-Type", "application/json")
        .body(user_data)
        .timeout(30)
        .build()
}

// Error handling with chains
safe_user_processing(user: User): Result = {
    user
        .validate()
        .and_then(normalize_user)
        .and_then(save_to_db)
        .map_err(log_error)
        .map(send_notification)
}

// =============================================================================
// PIPELINE OPERATOR - Functional Style
// =============================================================================

// Basic pipeline operations
process_numbers = |numbers| numbers
    |> filter(is_positive)
    |> map(square)
    |> reduce(add, 0)

// Data transformation pipeline
transform_user_data = |raw_data| raw_data
    |> parse_json
    |> validate_schema
    |> extract_users
    |> normalize_emails
    |> deduplicate
    |> sort_by_name

// Complex data processing pipeline
analyze_sales_data = |sales| sales
    |> filter_by_date_range(start_date, end_date)
    |> group_by_product
    |> calculate_totals
    |> sort_by_revenue
    |> take_top(10)
    |> format_report

// Async pipeline (conceptual)
fetch_and_process_data = |url| url
    |> fetch_data
    |> parse_response
    |> validate_data
    |> transform_format
    |> cache_result
    |> return_success

// Mathematical pipeline
calculate_statistics = |dataset| dataset
    |> remove_outliers
    |> calculate_mean
    |> calculate_std_dev
    |> normalize_values
    |> create_summary

// =============================================================================
// FIELD ACCESS CHAINING
// =============================================================================

// Deep field access
get_user_city = |user| user.profile.address.city
get_company_ceo_email = |company| company.leadership.ceo.contact.email

// Chained field access with null safety (conceptual)
safe_get_phone = |user| user
    .profile
    .contact_info
    .phone_number
    .or_default("No phone")

// Configuration access
get_database_url = |config| config
    .database
    .connection
    .primary
    .url

// Nested data structure navigation
extract_order_total = |order| order
    .items
    .map(get_item_price)
    .sum()

// =============================================================================
// MIXED CHAINING APPROACHES
// =============================================================================

// Combining method chains and pipelines
process_orders = |orders| orders
    .filter(is_pending)
    .map(validate_order)
    |> process_payments
    |> update_inventory
    |> send_confirmations

// Object methods with functional pipelines
user_onboarding = |user| user
    .create_profile()
    .set_preferences(default_prefs)
    |> send_welcome_email
    |> add_to_mailing_list
    |> track_signup_event

// Pipeline into method chain
data_pipeline = |raw_data| raw_data
    |> validate_format
    |> clean_data
    |> DataProcessor.new()
        .add_filters(common_filters)
        .set_output_format("json")
        .process()

// Method chain into pipeline
api_processing = |request| request
    .authenticate()
    .authorize()
    .extract_data()
    |> validate_business_rules
    |> apply_transformations
    |> format_response

// =============================================================================
// REAL-WORLD EXAMPLES
// =============================================================================

// E-commerce order processing
process_order = |order| {
    // Validation chain
    validated_order = order
        .validate_items()
        .check_inventory()
        .calculate_totals()
        .apply_discounts()

    // Payment processing pipeline
    payment_result = validated_order
        |> extract_payment_info
        |> validate_payment_method
        |> process_payment
        |> handle_payment_result

    // Fulfillment chain
    case payment_result {
        PaymentSuccess(transaction) -> order
            .update_status("paid")
            .reserve_inventory()
            .create_shipment()
            .send_confirmation_email()
        PaymentFailure(error) -> order
            .update_status("payment_failed")
            .log_error(error)
            .send_payment_retry_email()
    }
}

// User authentication flow
authenticate_user = |credentials| credentials
    |> validate_format
    |> hash_password
    |> lookup_user
    |> verify_password
    |> check_account_status
    |> create_session
    |> log_login_event

// Data analysis workflow
analyze_user_behavior = |events| {
    // Preprocessing chain
    cleaned_events = events
        .filter(is_valid_event)
        .deduplicate()
        .sort_by_timestamp()

    // Analysis pipeline
    insights = cleaned_events
        |> group_by_user
        |> calculate_session_duration
        |> identify_user_paths
        |> extract_conversion_funnels
        |> generate_insights

    // Reporting chain
    insights
        .format_for_dashboard()
        .add_visualizations()
        .export_to_pdf()
        .send_to_stakeholders()
}

// API request/response handling
handle_api_request = |request| request
    .validate_headers()
    .authenticate_user()
    .parse_body()
    |> validate_schema
    |> apply_business_logic
    |> format_response
    |> add_cors_headers
    |> log_request

// File processing workflow
process_uploaded_file = |file| file
    .validate_file_type()
    .check_file_size()
    .scan_for_malware()
    |> extract_metadata
    |> process_content
    |> generate_thumbnails
    |> save_to_storage
    |> update_database

// =============================================================================
// ADVANCED CHAINING PATTERNS
// =============================================================================

// Conditional chaining
smart_user_processing = |user| {
    base_processing = user
        .validate()
        .normalize()

    case user.type {
        PremiumUser -> base_processing
            .apply_premium_features()
            .send_premium_welcome()
        RegularUser -> base_processing
            .apply_basic_features()
            .send_regular_welcome()
        TrialUser -> base_processing
            .apply_trial_features()
            .schedule_trial_expiry()
    }
}

// Parallel processing with chaining
process_data_parallel = |data| {
    // Split processing into parallel chains
    user_data = data.users
        .validate_all()
        .normalize_all()
        .save_batch()

    order_data = data.orders
        .validate_all()
        .calculate_totals()
        .update_inventory()

    analytics_data = data.events
        |> aggregate_by_hour
        |> calculate_metrics
        |> update_dashboard

    // Combine results
    ProcessingResult.new()
        .add_users(user_data)
        .add_orders(order_data)
        .add_analytics(analytics_data)
        .finalize()
}

// Error recovery chains
resilient_processing = |data| data
    .attempt_primary_processing()
    .or_else(attempt_secondary_processing)
    .or_else(attempt_fallback_processing)
    .or_else(log_failure_and_continue)
    .unwrap_or_default()

// Lazy evaluation chains (conceptual)
lazy_data_pipeline = |source| source
    .lazy_filter(expensive_predicate)
    .lazy_map(expensive_transformation)
    .lazy_sort()
    .take(10)  // Only processes what's needed
    .force()   // Execute the lazy chain

// =============================================================================
// CHAINING WITH STRING INTERPOLATION
// =============================================================================

// Logging with chained operations
log_user_activity = |user| user
    .get_recent_actions()
    .filter(is_significant)
    .map(|action| "User {user.name} performed {action.type} at {action.timestamp}")
    .join_with_newlines()
    .log_to_file()

// Dynamic query building
build_user_query = |criteria| criteria
    .validate_criteria()
    .build_where_clause()
    .add_ordering()
    .add_pagination()
    .to_sql()
    .log_query("Executing query: {query}")

// Report generation
generate_user_report = |users| users
    .calculate_statistics()
    .format_data()
    .create_charts()
    .generate_summary(|stats| "Report generated with {stats.user_count} users, {stats.active_percent}% active")
    .save_to_file()

// =============================================================================
// PERFORMANCE CONSIDERATIONS
// =============================================================================

// Efficient chaining - avoiding intermediate collections
efficient_processing = |large_dataset| large_dataset
    .stream()           // Process as stream
    .filter(predicate)  // No intermediate collection
    .map(transform)     // No intermediate collection
    .take(1000)         // Limit early
    .collect()          // Only collect final result

// Memoized chaining for expensive operations
cached_processing = |data| data
    .memoize(expensive_validation)
    .memoize(expensive_transformation)
    .memoize(expensive_calculation)
    .get_final_result()

// =============================================================================
// TESTING CHAINING OPERATIONS
// =============================================================================

// Unit testing individual chain steps
test_user_validation_chain = || {
    test_user = create_test_user()

    result = test_user
        .validate()
        .normalize()
        .check_duplicates()

    assert(result.is_valid())
    assert(result.email.contains("@"))
    assert(result.name.is_capitalized())
}

// Integration testing full chains
test_order_processing_pipeline = || {
    test_order = create_test_order()

    result = test_order
        |> validate_order
        |> process_payment
        |> update_inventory
        |> send_confirmation

    assert(result.status == "completed")
    assert(result.payment.is_processed())
    assert(result.inventory.is_updated())
}

// =============================================================================
// CHAINING BEST PRACTICES DEMONSTRATED
// =============================================================================

// 1. Use method chaining for object state transformations
// 2. Use pipeline operator for functional data transformations
// 3. Keep chains readable - break long chains into variables
// 4. Use meaningful intermediate variable names
// 5. Handle errors appropriately in chains
// 6. Consider performance implications of chaining
// 7. Test individual steps and full chains
// 8. Use field access chaining for simple data extraction

// Example of well-structured chaining
process_customer_order = |order| {
    // Validation phase
    validated_order = order
        .validate_customer()
        .validate_items()
        .validate_shipping_address()

    // Processing phase
    processed_order = validated_order
        |> calculate_taxes
        |> apply_discounts
        |> calculate_shipping
        |> process_payment

    // Fulfillment phase
    fulfilled_order = processed_order
        .reserve_inventory()
        .create_shipping_label()
        .update_order_status()
        .send_confirmation()

    fulfilled_order
}

// =============================================================================
// CONCLUSION
// =============================================================================

// Keen's chaining syntax provides:
// ✅ Method chaining: object.method().method() for OOP-style operations
// ✅ Pipeline operator: data |> func |> func for functional transformations
// ✅ Field access chaining: object.field.subfield.value for data navigation
// ✅ Mixed approaches for flexible, readable code
// ✅ Integration with string interpolation, pattern matching, and all other features

// This makes Keen code highly readable, maintainable, and expressive!
