// Pattern Matching Test - Fixed Version with Simple Defined Types

// Define the types we need for testing
type Result = Ok(value: Int) | Error(message: String)
type Shape = Circle(radius: Float) | Rectangle(width: Float, height: Float)

// Simple pattern matching with Result type
process_result(result: Result): Int = {
    case result {
        Ok(value) -> value * 2
        Error(message) -> 0
    }
}

// Pattern matching with shapes - return Int to avoid type conversion issues
calculate_area_simple(shape: Shape): Int = {
    case shape {
        Circle(radius) -> 10  // Simplified return
        Rectangle(width, height) -> 20  // Simplified return
    }
}

// When expression for grading
calculate_grade(score: Int): String = {
    when score {
        >= 90 -> "A"
        >= 80 -> "B"
        >= 70 -> "C"
        >= 60 -> "D"
        _ -> "F"
    }
}

// Simple nested pattern matching
evaluate_simple(value: Int): Int = {
    case value {
        0 -> 0
        1 -> 10
        2 -> 20
        _ -> value * 5
    }
}

// Pattern matching with destructuring
extract_from_result(result: Result): Int = {
    case result {
        Ok(val) -> val + 100
        Error(_) -> -1
    }
}

// Pattern matching with shapes and destructuring
get_shape_info(shape: Shape): Int = {
    case shape {
        Circle(r) -> 1  // Circle type indicator
        Rectangle(w, h) -> 2  // Rectangle type indicator
    }
}

// When expression with complex conditions
classify_number(n: Int): Int = {
    when n {
        < 0 -> -1
        == 0 -> 0
        > 0 -> 1
        _ -> 999
    }
}

// Nested case expressions
process_nested(outer: Result): Int = {
    case outer {
        Ok(inner_value) -> {
            when inner_value {
                < 10 -> 1
                < 20 -> 2
                _ -> 3
            }
        }
        Error(_) -> 0
    }
}

// Main function to test all pattern matching
main(): Int = {
    // Test Result pattern matching
    success = Ok(value: 15)
    failure = Error(message: "test error")
    
    result1 = process_result(success)  // Should be 30 (15 * 2)
    result2 = process_result(failure)  // Should be 0
    
    // Test Shape pattern matching
    circle = Circle(radius: 5.0)
    rectangle = Rectangle(width: 10.0, height: 8.0)
    
    shape1 = calculate_area_simple(circle)     // Should be 10
    shape2 = calculate_area_simple(rectangle)  // Should be 20
    
    // Test when expressions
    grade1 = calculate_grade(85)  // Should be "B"
    grade2 = calculate_grade(95)  // Should be "A"
    
    // Test simple evaluation
    eval1 = evaluate_simple(1)    // Should be 10
    eval2 = evaluate_simple(5)    // Should be 25 (5 * 5)
    
    // Test extraction
    extract1 = extract_from_result(success)  // Should be 115 (15 + 100)
    extract2 = extract_from_result(failure)  // Should be -1
    
    // Test shape info
    info1 = get_shape_info(circle)     // Should be 1
    info2 = get_shape_info(rectangle)  // Should be 2
    
    // Test classification
    class1 = classify_number(-5)  // Should be -1
    class2 = classify_number(10)  // Should be 1
    
    // Test nested patterns
    nested1 = process_nested(success)  // Should be 2 (15 is >= 10, < 20)
    nested2 = process_nested(failure)  // Should be 0
    
    // Return sum to verify all tests worked
    result1 + result2 + shape1 + shape2 + eval1 + eval2 + 
    extract1 + extract2 + info1 + info2 + class1 + class2 + 
    nested1 + nested2
}

// Additional test functions for comprehensive coverage

// Test with different Result values
test_result_variations(): Int = {
    results = [
        Ok(value: 5),
        Ok(value: 10),
        Error(message: "error1"),
        Ok(value: 0)
    ]
    
    // Process each result and sum
    sum1 = process_result(Ok(value: 5))    // 10
    sum2 = process_result(Ok(value: 10))   // 20
    sum3 = process_result(Error(message: "error1"))  // 0
    sum4 = process_result(Ok(value: 0))    // 0
    
    sum1 + sum2 + sum3 + sum4  // Should be 30
}

// Test when expression edge cases
test_when_edges(): Int = {
    edge1 = when 90 {
        >= 90 -> 4
        >= 80 -> 3
        _ -> 0
    }
    
    edge2 = when 89 {
        >= 90 -> 4
        >= 80 -> 3
        _ -> 0
    }
    
    edge1 + edge2  // Should be 7 (4 + 3)
}

// Test pattern matching with literals
test_literal_patterns(): Int = {
    test1 = case 42 {
        42 -> 1
        _ -> 0
    }
    
    test2 = case 99 {
        42 -> 1
        _ -> 0
    }
    
    test1 + test2  // Should be 1 (1 + 0)
}

// Test wildcard patterns
test_wildcards(): Int = {
    test1 = case Ok(value: 123) {
        Ok(_) -> 100
        _ -> 0
    }
    
    test2 = case Error(message: "test") {
        Ok(_) -> 100
        _ -> 200
    }
    
    test1 + test2  // Should be 300 (100 + 200)
}