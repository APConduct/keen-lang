// Test with field access to isolate the verifier error
// This adds field access back to see if that's the issue

// Product type definition
type User = User(id: Int, name: String, email: String, age: Int)

// Union type definition
type Result = Ok(value: String) | Error(message: String)

// Create user with constructor
user1 = User(id: 1, name: "Alice", email: "alice@test.com", age: 25)

// Create result values
success = Ok(value: "Operation completed")
failure = Error(message: "Something went wrong")

// Function with mutability on parameters WITH field access
update_user_with_field(live user: User, new_name: String): User {
    User(id: user.id, name: new_name, email: user.email, age: user.age)
}

// Simple function that returns Result (NO pattern matching)
create_success(): Result {
    Ok(value: "Hello World")
}

// Simple function that takes Result (NO pattern matching)
check_result(result: Result): Int {
    42  // Just return a constant
}

// Variable with type annotation
live counter: Int = 0

// Keep constant
keep MAX_USERS = 1000

// Test the features with field access but NO pattern matching
main() {
    // Constructor usage
    alice = User(id: 1, name: "Alice", email: "alice@example.com", age: 30)

    // Union type usage
    result = Ok(value: "Hello World")
    status = check_result(result)

    // User update with field access (this might cause the verifier error)
    updated_user = update_user_with_field(alice, "Bob")

    // Mutability test
    counter = counter + 1

    // Return simple result
    counter + status
}
