// Chaining Operations Test Program
// This program demonstrates Keen's method chaining and pipeline operator capabilities

// Simple data processing functions for testing
filter_positive = |x| x > 0
double = |x| x * 2
add_ten = |x| x + 10
square = |x| x * x

// Mock list operations (these would be implemented in the standard library)
mock_filter(list: List, predicate: Function): List = list  // Simplified
mock_map(list: List, transform: Function): List = list     // Simplified
mock_reduce(list: List, combiner: Function, initial: Any): Any = initial  // Simplified

// Test basic pipeline operations
test_basic_pipeline(): Int = {
    result = 5
        |> double
        |> add_ten
        |> square

    result  // Should be ((5 * 2 + 10) ^ 2) = 400
}

// Test method chaining with mock objects
type Calculator = Calculator(value: Int)

add_value(calc: Calculator, n: Int): Calculator = Calculator(calc.value + n)
multiply_value(calc: Calculator, n: Int): Calculator = Calculator(calc.value * n)
get_result(calc: Calculator): Int = calc.value

test_method_chaining(): Int = {
    calculator = Calculator(value: 10)

    result = calculator
        .add_value(5)
        .multiply_value(3)
        .add_value(2)
        .get_result()

    result  // Should be ((10 + 5) * 3 + 2) = 47
}

// Test field access chaining
type User = User(
    name: String,
    profile: Profile,
    settings: Settings
)

type Profile = Profile(
    email: String,
    address: Address
)

type Address = Address(
    street: String,
    city: String,
    country: String
)

type Settings = Settings(
    theme: String,
    notifications: Boolean
)

test_field_chaining(): String = {
    user = User(
        name: "Alice",
        profile: Profile(
            email: "alice@example.com",
            address: Address(
                street: "123 Main St",
                city: "San Francisco",
                country: "USA"
            )
        ),
        settings: Settings(
            theme: "dark",
            notifications: true
        )
    )

    // Deep field access
    city = user.profile.address.city
    theme = user.settings.theme

    "User in {city} prefers {theme} theme"
}

// Test mixed chaining (method + pipeline)
test_mixed_chaining(): Int = {
    data = Calculator(value: 3)

    result = data
        .add_value(7)     // Calculator(10)
        .multiply_value(2) // Calculator(20)
        .get_result()      // 20
        |> add_ten         // 30
        |> double          // 60
        |> square          // 3600

    result
}

// Test chaining with string interpolation
format_chain_result(value: Int): String = {
    message = "Processing value: {value}"
        |> append_text(" -> doubled")
        |> append_text(" -> squared")
        |> append_text(" -> final result")

    message
}

append_text(base: String, addition: String): String = "{base}{addition}"

// Test complex data pipeline
type DataProcessor = DataProcessor(
    data: List,
    filters: List,
    transformations: List
)

add_filter(processor: DataProcessor, filter: Function): DataProcessor =
    DataProcessor(
        data: processor.data,
        filters: processor.filters.append(filter),
        transformations: processor.transformations
    )

add_transformation(processor: DataProcessor, transform: Function): DataProcessor =
    DataProcessor(
        data: processor.data,
        filters: processor.filters,
        transformations: processor.transformations.append(transform)
    )

process_data(processor: DataProcessor): List = {
    // Apply all filters and transformations
    // This is a simplified version
    processor.data
}

test_data_processing(): List = {
    initial_data = [1, -2, 3, -4, 5, 6]

    result = DataProcessor(
        data: initial_data,
        filters: [],
        transformations: []
    )
    .add_filter(filter_positive)
    .add_transformation(double)
    .add_transformation(add_ten)
    .process_data()

    result
}

// Test error handling with chaining
type Result = Ok(value: Any) | Error(message: String)

safe_divide(x: Int, y: Int): Result = {
    case y {
        0 -> Error("Division by zero")
        _ -> Ok(x / y)
    }
}

chain_result(result: Result, operation: Function): Result = {
    case result {
        Ok(value) -> operation(value)
        Error(msg) -> Error(msg)
    }
}

test_error_chaining(): Result = {
    result = Ok(20)
        |> chain_result(|x| safe_divide(x, 4))  // Ok(5)
        |> chain_result(|x| safe_divide(x, 0))  // Error
        |> chain_result(|x| safe_divide(x, 2))  // Still Error

    result
}

// Test functional composition with chaining
compose_operations = |x| x
    |> filter_positive
    |> double
    |> add_ten

test_composition(): List = {
    numbers = [1, -2, 3, -4, 5]

    // Apply composition to each number
    results = numbers.map(compose_operations)

    results
}

// Test builder pattern with chaining
type HttpRequest = HttpRequest(
    method: String,
    url: String,
    headers: Map,
    body: String
)

new_request(): HttpRequest = HttpRequest(
    method: "GET",
    url: "",
    headers: {},
    body: ""
)

set_method(request: HttpRequest, method: String): HttpRequest =
    HttpRequest(
        method: method,
        url: request.url,
        headers: request.headers,
        body: request.body
    )

set_url(request: HttpRequest, url: String): HttpRequest =
    HttpRequest(
        method: request.method,
        url: url,
        headers: request.headers,
        body: request.body
    )

add_header(request: HttpRequest, key: String, value: String): HttpRequest =
    HttpRequest(
        method: request.method,
        url: request.url,
        headers: request.headers.insert(key, value),
        body: request.body
    )

set_body(request: HttpRequest, body: String): HttpRequest =
    HttpRequest(
        method: request.method,
        url: request.url,
        headers: request.headers,
        body: body
    )

test_builder_pattern(): HttpRequest = {
    request = new_request()
        .set_method("POST")
        .set_url("/api/users")
        .add_header("Content-Type", "application/json")
        .add_header("Authorization", "Bearer token123")
        .set_body('{"name": "Alice", "email": "alice@example.com"}')

    request
}

// Main function to run all tests
main(): Int = {
    // Run all chaining tests
    pipeline_result = test_basic_pipeline()          // 400
    method_result = test_method_chaining()           // 47
    field_result = test_field_chaining()             // "User in San Francisco prefers dark theme"
    mixed_result = test_mixed_chaining()             // 3600

    // Test data processing
    processed_data = test_data_processing()

    // Test error handling
    error_result = test_error_chaining()

    // Test composition
    composed_results = test_composition()

    // Test builder pattern
    http_request = test_builder_pattern()

    // Format results with string interpolation
    summary = "Chaining Tests Completed:"
    pipeline_msg = "Pipeline result: {pipeline_result}"
    method_msg = "Method chaining result: {method_result}"
    mixed_msg = "Mixed chaining result: {mixed_result}"

    // Return a simple success indicator
    case error_result {
        Ok(_) -> 0      // Success
        Error(_) -> 1   // Expected error occurred
    }
}

// Demonstration of advanced chaining patterns
demo_advanced_chaining(): String = {
    // Simulate a data processing workflow
    raw_data = "user_data.csv"

    result = raw_data
        |> load_file
        |> parse_csv
        |> validate_data
        |> filter_active_users
        |> normalize_emails
        |> sort_by_name
        |> take_first(100)
        |> format_report
        |> save_to_file("processed_users.json")

    "Advanced chaining workflow completed: {result}"
}

// Mock functions for the advanced demo
load_file(filename: String): List = []
parse_csv(data: List): List = data
validate_data(data: List): List = data
filter_active_users(data: List): List = data
normalize_emails(data: List): List = data
sort_by_name(data: List): List = data
take_first(data: List, n: Int): List = data
format_report(data: List): String = "Report generated"
save_to_file(content: String, filename: String): String = "Saved to {filename}"

// Summary of chaining capabilities tested:
// ✅ Pipeline operator: value |> function |> function
// ✅ Method chaining: object.method().method().method()
// ✅ Field access chaining: object.field.subfield.value
// ✅ Mixed chaining: object.method() |> function |> object2.method()
// ✅ Error handling chains: Result chaining with proper propagation
// ✅ Builder pattern: Fluent API construction
// ✅ Functional composition: Pipeline of transformations
// ✅ Data processing workflows: Complex multi-step operations
