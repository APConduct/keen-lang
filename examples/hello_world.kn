// =============================================================================
// HELLO WORLD - Keen Language Example (Modern Syntax)
// =============================================================================
// This demonstrates all modern Keen features:
// - String interpolation
// - Method chaining
// - Pipeline operators
// - Constructor syntax
// - Pattern matching
// - Block expressions
// =============================================================================

main() = {
    // Basic text output with string interpolation
    print("Hello, World!")
    print("Welcome to the Keen programming language!")

    // Print different data types with interpolation
    age = 42
    pi = 3.14159
    is_active = true
    is_complete = false

    print("Age: {age}")
    print("Pi: {pi}")
    print("Active: {is_active}")
    print("Complete: {is_complete}")

    // Variables and expressions with string interpolation
    name = "Keen"
    version = 2.0
    print("Language: {name}")
    print("Version: {version}")

    // Arithmetic expressions with interpolation
    x = 10
    y = 20
    sum = x + y
    print("{x} + {y} = {sum}")

    // Function calls with chaining and interpolation
    result = calculate(5, 3)
        .validate()
        .format()
    print("calculate(5, 3) = {result}")

    // Conditional output with enhanced ternary
    score = 95
    grade = score >= 90 ? "A" : score >= 80 ? "B" : "C"
    print("Score {score} gets grade: {grade}")

    // Block expressions with chaining and interpolation
    analysis = {
        data = [1, 2, 3, 4, 5]

        total = data
            |> filter(|x| x > 0)
            |> reduce(add, 0)

        average = total / data.length

        print("Data: {data}")
        print("Total: {total}")
        print("Average: {average}")

        AnalysisResult(total: total, average: average, count: data.length)
    }

    print("Analysis: total={analysis.total}, avg={analysis.average}")
}

// Helper function with string interpolation
calculate(a: Int, b: Int): CalculationResult = {
    result = a * b + a - b
    print("Calculating: {a} * {b} + {a} - {b} = {result}")

    CalculationResult(
        operand1: a,
        operand2: b,
        result: result,
        formula: "{a} * {b} + {a} - {b}"
    )
}

// List processing function with chaining
sum_list(numbers: List): Int = {
    case numbers {
        [] -> {
            print("Summing empty list")
            0
        }
        [head, ...tail] -> {
            tail_sum = sum_list(tail)
            total = head + tail_sum
            print("Adding {head} to partial sum {tail_sum} = {total}")
            total
        }
    }
}

// Pipeline-based list processing
process_numbers = |numbers| numbers
    |> filter(|x| x > 0)
    |> map(|x| x * 2)
    |> reduce(add, 0)

// Demonstration of pattern matching with modern syntax
process_shape(shape: Shape): ShapeResult = {
    result = case shape {
        Circle(radius) -> {
            area = 3.14159 * radius * radius
            print("Circle with radius {radius} has area {area}")
            ShapeResult(type: "circle", area: area, description: "Circle(r={radius})")
        }
        Rectangle(width, height) -> {
            area = width * height
            print("Rectangle {width}x{height} has area {area}")
            ShapeResult(type: "rectangle", area: area, description: "Rectangle({width}x{height})")
        }
        Triangle(base, height) -> {
            area = 0.5 * base * height
            print("Triangle with base {base} and height {height} has area {area}")
            ShapeResult(type: "triangle", area: area, description: "Triangle(b={base}, h={height})")
        }
    }

    result
        .validate()
        .log_calculation()
}

// Lambda expressions with modern chaining and interpolation
demo_lambdas() = {
    print("=== Lambda Expressions Demo ===")

    // Simple lambda with pipeline
    double = |x| x * 2
    numbers = [1, 2, 3, 4, 5]

    processed = numbers
        |> map(double)
        |> filter(|x| x > 4)
        |> sort()

    print("Original: {numbers}")
    print("Processed (doubled, filtered >4, sorted): {processed}")

    // Lambda with multiple parameters and interpolation
    add = |x, y| {
        result = x + y
        print("Adding {x} + {y} = {result}")
        result
    }

    sum_result = add(10, 15)
    print("Final sum: {sum_result}")

    // Higher-order function with method chaining
    apply_twice = |func, value| value
        |> func
        |> func

    result = apply_twice(double, 3)
    print("apply_twice(double, 3) = {result}")

    // Complex lambda chain
    complex_processing = numbers
        .map(|x| x * 2)
        .filter(|x| x > 5)
        .reduce(|acc, x| {
            new_acc = acc + x
            print("Accumulating: {acc} + {x} = {new_acc}")
            new_acc
        }, 0)

    print("Complex processing result: {complex_processing}")
}

// Error handling with chaining and interpolation
safe_divide(a: Float, b: Float): Result = {
    validation_result = case b {
        0.0 -> {
            print("Error: Cannot divide {a} by zero!")
            Error("Division by zero")
        }
        _ -> {
            result = a / b
            print("Successfully divided {a} by {b} = {result}")
            Ok(result)
        }
    }

    validation_result
        .map(|result| DivisionResult(dividend: a, divisor: b, quotient: result))
        .map_err(|error| "Math error: {error}")
}

// Chained error handling
process_calculations = |operations| operations
    .map(|(a, b)| safe_divide(a, b))
    .filter_ok()
    .map(|result| result.quotient)
    .reduce(add, 0.0)

// User interaction simulation with modern features
simulate_user_interaction() = {
    print("=== User Interaction Simulation ===")

    // Simulated user data with constructor syntax
    users = [
        User(id: 1, name: "Alice", age: 28, email: "alice@example.com"),
        User(id: 2, name: "Bob", age: 35, email: "bob@example.com"),
        User(id: 3, name: "Carol", age: 22, email: "carol@example.com")
    ]

    print("Processing {users.length} users:")

    // Enhanced processing with chaining and interpolation
    processed_users = users
        .validate_all()
        .sort_by(|u| u.age)
        .map(|user| {
            case user {
                User(id, name, age, email) -> {
                    print("User #{id}: {name}")
                    print("  Age: {age}")
                    print("  Email: {email}")

                    category = when age {
                        < 25 -> "Young Professional"
                        < 35 -> "Experienced Professional"
                        _ -> "Senior Professional"
                    }

                    print("  Category: {category}")
                    print("---")

                    UserProfile(
                        user: user,
                        category: category,
                        status: "processed",
                        processed_at: now()
                    )
                }
            }
        })

    // Summary with pipeline
    summary = processed_users
        |> group_by(|p| p.category)
        |> map_values(|group| group.length)
        |> format_summary

    print("Summary: {summary}")
}

// Comprehensive demo with all modern features
run_all_demos() = {
    print("ðŸš€ Keen Language - Complete Modern Syntax Demo")
    print("==============================================")

    print("\nðŸ“± Main Demo:")
    main()

    print("\nðŸ“Š Lambda & Chaining Demo:")
    demo_lambdas()

    print("\nðŸ‘¥ User Processing Demo:")
    simulate_user_interaction()

    print("\nðŸ”º Shape Processing Demo:")
    shapes = [
        Circle(radius: 5.0),
        Rectangle(width: 10.0, height: 6.0),
        Triangle(base: 8.0, height: 4.0)
    ]

    results = shapes
        .map(process_shape)
        .sort_by(|r| r.area)
        .map(|r| "Processed {r.type}: area={r.area}")

    results.for_each(print)

    print("\nâš ï¸ Error Handling Demo:")
    test_cases = [(10.0, 2.0), (10.0, 0.0), (15.0, 3.0)]

    calculation_results = test_cases
        |> map(|(a, b)| safe_divide(a, b))
        |> map(|result| case result {
            Ok(div_result) -> "âœ… {div_result.dividend}/{div_result.divisor} = {div_result.quotient}"
            Error(msg) -> "âŒ {msg}"
        })

    calculation_results.for_each(print)

    print("\nðŸŽ‰ All demos completed successfully!")
    print("Keen's modern syntax is fully functional with:")
    print("  â€¢ String interpolation: \"Hello, {name}!\"")
    print("  â€¢ Method chaining: obj.method().method()")
    print("  â€¢ Pipeline operators: data |> func |> func")
    print("  â€¢ Constructor syntax: Type(field: value)")
    print("  â€¢ Enhanced pattern matching")
    print("  â€¢ Block expressions with implicit returns")
}

// Additional type definitions for modern syntax
type CalculationResult = CalculationResult(
    operand1: Int,
    operand2: Int,
    result: Int,
    formula: String
)

type ShapeResult = ShapeResult(
    type: String,
    area: Float,
    description: String
)

type DivisionResult = DivisionResult(
    dividend: Float,
    divisor: Float,
    quotient: Float
)

type UserProfile = UserProfile(
    user: User,
    category: String,
    status: String,
    processed_at: String
)

type AnalysisResult = AnalysisResult(
    total: Int,
    average: Float,
    count: Int
)

// Entry point
run_all_demos()
