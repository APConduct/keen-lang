// =============================================================================
// KEEN LANGUAGE - NEW FEATURES DEMONSTRATION
// =============================================================================
// This file showcases all the major features that were recently implemented:
// - Product types with named fields
// - Union types (sum types)
// - Constructor expressions with named arguments
// - Parameter mutability (live/keep)
// - Variable type annotations
// - Enhanced pattern matching
// =============================================================================

// =============================================================================
// PRODUCT TYPES - Structured data with named fields
// =============================================================================

// Basic product type - represents a point in 2D space
type Point = Point(x: Float, y: Float)

// More complex product type - user information
type User = User(
    id: Int,
    name: String,
    email: String,
    age: Int
)

// Product type for geometric shapes
type Rectangle = Rectangle(width: Float, height: Float, position: Point)

// =============================================================================
// UNION TYPES - Sum types for representing alternatives
// =============================================================================

// Classic Result type for error handling
type Result = Ok(value: String) | Error(message: String)

// Option type for nullable values
type Option = Some(value: Int) | None()

// Shape union - different geometric shapes
type Shape =
    Circle(radius: Float) |
    Rectangle(width: Float, height: Float) |
    Triangle(base: Float, height: Float)

// HTTP request types
type HttpRequest =
    Get(path: String) |
    Post(path: String, body: String) |
    Put(path: String, body: String) |
    Delete(path: String)

// =============================================================================
// CONSTRUCTOR EXPRESSIONS - Creating instances with named arguments
// =============================================================================

// Create users with named constructor arguments
alice: User = User(
    id: 1,
    name: "Alice Johnson",
    email: "alice@example.com",
    age: 28
)

bob: User = User(
    id: 2,
    name: "Bob Smith",
    email: "bob@example.com",
    age: 35
)

// Create geometric objects
origin: Point = Point(x: 0.0, y: 0.0)
center: Point = Point(x: 100.0, y: 50.0)

main_rect: Rectangle = Rectangle(
    width: 200.0,
    height: 100.0,
    position: center
)

// Create union type instances
success_result: Result = Ok(value: "Operation completed successfully")
error_result: Result = Error(message: "Network connection failed")

some_value: Option = Some(value: 42)
no_value: Option = None()

// =============================================================================
// FUNCTIONS WITH PARAMETER MUTABILITY
// =============================================================================

// Function with immutable parameters (default)
calculate_distance(p1: Point, p2: Point): Float = {
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    sqrt(dx * dx + dy * dy)
}

// Function with mutable parameter - can modify the cache
update_user_cache(live cache: Map, user: User): Unit = {
    cache.insert(user.id, user)
}

// Function with keep parameter - treats input as constant
validate_email(keep email_pattern: String, email: String): Boolean = {
    // email_pattern is immutable and non-shadowable
    email.matches(email_pattern)
}

// Mixed parameter mutability
process_user_data(
    live users: List,
    keep max_age: Int,
    user: User
): Result = {
    when user.age {
        > max_age -> Error(message: "User too old")
        < 0 -> Error(message: "Invalid age")
        _ -> {
            users.append(user)
            Ok(value: "User processed successfully")
        }
    }
}

// =============================================================================
// VARIABLE DECLARATIONS WITH TYPE ANNOTATIONS
// =============================================================================

// Basic type annotations
counter: Int = 0
pi: Float = 3.14159
app_name: String = "Keen Demo"
is_running: Boolean = true

// Mutability with type annotations
live active_users: Int = 0
live session_cache: Map = {}
keep max_connections: Int = 1000
keep app_version: String = "1.0.0"

// Complex type annotations
live user_list: List = []
current_user: Option = None()
last_result: Result = Ok(value: "Initial state")

// =============================================================================
// PATTERN MATCHING WITH NEW TYPES
// =============================================================================

// Process HTTP requests
handle_request(request: HttpRequest): String = {
    case request {
        Get(path) -> "Serving file: " + path
        Post(path, body) -> {
            // Process POST data
            "Posted to " + path + " with data: " + body
        }
        Put(path, body) -> "Updated " + path + " with: " + body
        Delete(path) -> "Deleted resource at: " + path
    }
}

// Handle results with pattern matching
process_result(result: Result): String = {
    case result {
        Ok(value) -> {
            log("Success: " + value)
            value
        }
        Error(message) -> {
            log("Error occurred: " + message)
            "Failed"
        }
    }
}

// Calculate shape areas
calculate_area(shape: Shape): Float = {
    case shape {
        Circle(radius) -> 3.14159 * radius * radius
        Rectangle(width, height) -> width * height
        Triangle(base, height) -> 0.5 * base * height
    }
}

// Handle optional values
get_value_or_default(opt: Option, default_val: Int): Int = {
    case opt {
        Some(value) -> value
        None() -> default_val
    }
}

// =============================================================================
// ADVANCED PATTERN MATCHING
// =============================================================================

// Nested pattern matching
analyze_user(user: User): String = {
    case user {
        User(id, name, email, age) -> {
            when age {
                < 18 -> name + " is a minor"
                >= 18, < 65 -> name + " is an adult"
                >= 65 -> name + " is a senior"
                _ -> name + " has invalid age"
            }
        }
    }
}

// Pattern matching with guards
categorize_shape(shape: Shape): String = {
    case shape {
        Circle(radius) -> {
            when radius {
                <= 1.0 -> "Small circle"
                <= 10.0 -> "Medium circle"
                _ -> "Large circle"
            }
        }
        Rectangle(width, height) -> {
            area = width * height
            when area {
                <= 10.0 -> "Small rectangle"
                <= 100.0 -> "Medium rectangle"
                _ -> "Large rectangle"
            }
        }
        Triangle(base, height) -> "Triangle with base " + base
    }
}

// =============================================================================
// REAL-WORLD EXAMPLE - USER MANAGEMENT SYSTEM
// =============================================================================

// User management with all new features
type UserManager = UserManager(
    live users: Map,
    live active_sessions: Map,
    keep max_users: Int
)

// Create user manager instance
live user_manager: UserManager = UserManager(
    users: {},
    active_sessions: {},
    max_users: 1000
)

// Register new user
register_user(
    live manager: UserManager,
    name: String,
    email: String,
    age: Int
): Result = {
    when manager.users.size() {
        >= manager.max_users -> Error(message: "Maximum users reached")
        _ -> {
            new_id = manager.users.size() + 1
            new_user = User(
                id: new_id,
                name: name,
                email: email,
                age: age
            )

            manager.users.insert(new_id, new_user)
            Ok(value: "User registered: " + name)
        }
    }
}

// Login user
login_user(live manager: UserManager, user_id: Int): Result = {
    case manager.users.get(user_id) {
        Some(user) -> {
            session_id = generate_session_id()
            manager.active_sessions.insert(session_id, user)
            Ok(value: "User logged in: " + user.name)
        }
        None() -> Error(message: "User not found")
    }
}

// =============================================================================
// DEMONSTRATION MAIN FUNCTION
// =============================================================================

demo_main(): Unit = {
    // Create some users
    alice_result = register_user(user_manager, "Alice", "alice@test.com", 25)
    bob_result = register_user(user_manager, "Bob", "bob@test.com", 30)

    // Process results
    alice_message = process_result(alice_result)
    bob_message = process_result(bob_result)

    // Create shapes and calculate areas
    circle = Circle(radius: 5.0)
    rectangle = Rectangle(width: 10.0, height: 8.0)
    triangle = Triangle(base: 6.0, height: 4.0)

    circle_area = calculate_area(circle)
    rect_area = calculate_area(rectangle)
    tri_area = calculate_area(triangle)

    // Handle HTTP requests
    get_req = Get(path: "/users")
    post_req = Post(path: "/users", body: "{'name': 'Charlie'}")

    get_response = handle_request(get_req)
    post_response = handle_request(post_req)

    // Print results
    print("=== User Registration ===")
    print(alice_message)
    print(bob_message)

    print("\n=== Shape Areas ===")
    print("Circle area: " + circle_area)
    print("Rectangle area: " + rect_area)
    print("Triangle area: " + tri_area)

    print("\n=== HTTP Responses ===")
    print(get_response)
    print(post_response)

    print("\n=== Demo Complete ===")
    print("All new features demonstrated successfully!")
}

// =============================================================================
// FEATURE SUMMARY
// =============================================================================
/*
NEW FEATURES DEMONSTRATED:

✅ Product Types:
   - User, Point, Rectangle types with named fields
   - Constructor syntax: User(id: 1, name: "Alice", ...)

✅ Union Types:
   - Result, Option, Shape, HttpRequest with multiple variants
   - Pattern matching: case shape { Circle(r) -> ... }

✅ Constructor Expressions:
   - Named arguments: User(id: 1, name: "Alice")
   - Nested constructors: Rectangle(position: Point(x: 0, y: 0))

✅ Parameter Mutability:
   - live parameters: can be modified in function
   - keep parameters: immutable constants
   - Mixed mutability in function signatures

✅ Variable Type Annotations:
   - Basic: counter: Int = 0
   - With mutability: live cache: Map = {}
   - Complex types: user_list: List = []

✅ Enhanced Pattern Matching:
   - Destructuring product types
   - Matching union variants
   - Nested patterns with when expressions

This demonstrates a significant advancement in Keen's type system and
expressiveness, bringing it closer to modern functional languages
while maintaining its unique mutability model.
*/
