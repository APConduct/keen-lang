// =============================================================================
// PRODUCT TYPE DEFINITIONS
// =============================================================================

// Simple nominal types
type UserId = UserId(id: Int)
type ProductId = ProductId(id: Int)
type Email = Email(address: String)

// Complex product types
type User = User(id: UserId, name: String, email: Email, age: Int)
type Product = Product(id: ProductId, name: String, price: Float, category: String)
type Order = Order(id: Int, user: UserId, items: List, total: Float)

// Geometric types (same structure, different meaning)
type Point = Point(x: Float, y: Float)
type Vector = Vector(x: Float, y: Float)
type Size = Size(width: Float, height: Float)

// Result type for error handling
type Result = Ok(value: Any) | Error(message: String)

// Option type
type Option = Some(value: Any) | None

// =============================================================================
// NOMINAL TYPING IN ACTION
// =============================================================================

// These functions only accept their specific nominal types
create_user(name: String, email_str: String, age: Int): Result {
    email = Email(address: email_str)
    id = generate_user_id()

    validation_result = when age {
        < 0 -> Error("Age cannot be negative")
        > 150 -> Error("Age seems unrealistic")
        _ -> Ok(age)
    }

    case validation_result {
        Ok(_) -> {
            user = User(id: id, name: name, email: email, age: age)
            print("Created user: {name} with ID {id}")
            Ok(user)
        }
        Error(msg) -> Error("User creation failed: {msg}")
    }
}

process_order(order: Order): Result {
    user_result = fetch_user(order.user)

    case user_result {
        Some(user) -> {
            total = order.items
                .map(get_item_price)
                .reduce(add, 0.0)

            payment_result = user
                .validate_payment_method()
                .charge(total)

            case payment_result {
                Ok(transaction) -> {
                    print("Processed order for {user.name}, total: ${total}")
                    Ok(transaction)
                }
                Error(msg) -> Error("Payment failed: {msg}")
            }
        }
        None -> Error("User {order.user} not found")
    }
}

// Nominal types prevent mixing up IDs
transfer_money(from: UserId, to: UserId, amount: Float): Result {
    from_user = fetch_user(from)
    to_user = fetch_user(to)

    case (from_user, to_user) {
        (Some(sender), Some(receiver)) -> {
            transaction = sender
                .validate_balance(amount)
                .and_then(|_| sender.debit(amount))
                .and_then(|_| receiver.credit(amount))
                .map(|_| print("Transferred ${amount} from {sender.name} to {receiver.name}"))

            transaction
        }
        _ -> Error("One or both users not found")
    }
}

// This would be a compile error:
// transfer_money(ProductId(id: 123), UserId(id: 456), 100.0)  // Error!

// =============================================================================
// STRUCTURAL OPERATIONS
// =============================================================================

// These work structurally - any type with .x and .y fields
distance(p1, p2): Float = {
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    result = sqrt(dx * dx + dy * dy)
    print("Distance between ({p1.x}, {p1.y}) and ({p2.x}, {p2.y}) is {result}")
    result
}

translate(shape, offset) {
    // Works with any shape that has .x and .y
    translated = shape
        .update_x(shape.x + offset.x)
        .update_y(shape.y + offset.y)

    print("Translated shape by offset ({offset.x}, {offset.y})")
    translated
}

// All of these work because of structural compatibility:
point = Point(1.0, 2.0)
vector = Vector(3.0, 4.0)
size = Size(5.0, 6.0)

dist1 = distance(point, vector)  // OK - both have .x, .y
dist2 = distance(vector, size)   // OK - both have .x, .y

translated_point = point |> translate(_, vector)  // OK
translated_size = size |> translate(_, vector)    // OK

// =============================================================================
// PATTERN MATCHING WITH PRODUCT TYPES
// =============================================================================

// Destructuring in case expressions with string interpolation
handle_user_request(user: User, request): Result {
    case user {
        User(id, name, email, age) -> {
            print("Processing request for user: {name}")

            case request {
                GetProfile -> user
                    .serialize()
                    .add_timestamp()
                    .format_response()

                UpdateEmail(new_email) -> {
                    updated_user = User(
                        id: id,
                        name: name,
                        email: Email(address: new_email),
                        age: age
                    )

                    updated_user
                        .validate()
                        .save()
                        .map(|u| "Email updated for {u.name}")
                }

                DeleteAccount -> {
                    when age {
                        < 18 -> Error("Minors cannot delete accounts")
                        _ -> user
                            .deactivate()
                            .anonymize()
                            .log_deletion("Account deleted for {name}")
                    }
                }
            }
        }
    }
}

// Partial destructuring
get_user_name(user: User): String {
    case user {
        User(_, name, _, _) -> {
            print("Extracted name: {name}")
            name  // Only care about name
        }
    }
}

// Or with field access (structural) - enhanced with chaining
get_user_name_alt(user) = user.name
    .trim()
    .to_title_case()  // Works structurally with chaining

// =============================================================================
// ADVANCED PATTERNS
// =============================================================================

// Nested product types
type Address = Address(street: String, city: String, zip: String)
type Customer = Customer(user: User, address: Address, orders: List[Order])

// Deep pattern matching with string interpolation
validate_customer(customer: Customer): Result {
    case customer {
        Customer(User(_, *, Email(email), age), Address(*, _, zip), orders) -> {
            validation_errors = []

            when age {
                < 18 -> validation_errors.push("Must be 18 or older, got {age}")
                _ -> {}
            }

            when !valid_email(email) {
                true -> validation_errors.push("Invalid email: {email}")
                _ -> {}
            }

            when !valid_zip(zip) {
                true -> validation_errors.push("Invalid zip code: {zip}")
                _ -> {}
            }

            case validation_errors.length {
                0 -> {
                    when orders.length {
                        0 -> Warning("Customer {customer.user.name} has no order history")
                        _ -> {
                            print("Customer validation passed for {customer.user.name}")
                            Ok(customer)
                        }
                    }
                }
                _ -> Error("Validation failed: {validation_errors.join(", ")}")
            }
        }
    }
}

// Generic-like behavior through structural typing with string interpolation
serialize_entity(entity) {
    // Works with any type that has .name field
    timestamp = now()
    "{ \"name\": \"{entity.name}\", \"serialized_at\": \"{timestamp}\" }"
}

live entities = [
    User(id: UserId(id: 1), name: "Alice", email: Email(address: "alice@test.com"), age: 25),
    Product(id: ProductId(id: 100), name: "Widget", price: 19.99, category: "Tools")
]

// Both User and Product have .name, so this works with chaining:
serialized = entities
    .filter(|e| e.name.length > 0)
    .map(serialize_entity)
    .join_with_newlines()

// =============================================================================
// CONSTRUCTION AND DESTRUCTION
// =============================================================================

// Constructor functions are just regular functions with chaining
make_point(x: Float, y: Float): Point = Point(x: x, y: y)
    .validate_coordinates()
    .normalize_if_needed()

// Destructuring assignment
Point(x, y) = get_mouse_position()
User(user_id, username, _, _) = current_user

// Update patterns (functional style) with string interpolation
update_user_age(user: User, new_age: Int): User {
    case user {
        User(id, name, email, _) -> {
            updated = User(id: id, name: name, email: email, age: new_age)
            print("Updated {name}'s age from {user.age} to {new_age}")
            updated
        }
    }
}

// Chaining-based update approach
update_user_age_chaining(user: User, new_age: Int): User = user
    .validate_age_change(new_age)
    .update_age(new_age)
    .log_change("Age updated to {new_age}")
    .save()
